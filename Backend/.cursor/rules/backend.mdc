---
description: レイヤードアーキテクチャ (C#)
globs: *.cs
alwaysApply: false
---

# レイヤードアーキテクチャのバックエンドガイドライン

## レイヤー構造の責務

### Presentation (Interface) Layer (プレゼン層)
- HTTP API エンドポイントを提供し、ルーティングを担当します。
- リクエスト/レスポンスの受け渡しを行い、認証・認可を実施します。
- サーバーサイドのバリデーションや簡単な入力チェックのみを担当し、ビジネスロジックはアプリケーション層に委譲します。
- `Presentation` フォルダは、以下のように作成するコンポーネントや機能に応じて、`Controllers`, `DTOs`, `Middlewares` などのサブフォルダを作成します：
  - `Presentation`
    - `Controllers` (コントローラー)
    - `DTOs` (データ転送オブジェクト)
    - `Middlewares` (ミドルウェア)

### Application Layer (アプリ層)
- ユースケースに沿ったビジネスロジックを実装し、ドメイン層のモデルを利用して処理を調整します。
- トランザクションの開始と終了を管理し、必要に応じて複数のリポジトリやサービスを組み合わせます。
- ドメイン層とのインターフェースとしてサービス・インターフェースを定義し、実装はインフラ層に依存します。
- `Application` フォルダは、以下のようにサービスを配置する、`Services`, インターフェースを配置する `Interfaces` のサブフォルダを作成します：
  - `Application`
    - `Interfaces` (インターフェース)
    - `Services` (サービス)

### Domain Layer (ドメイン層)
- ドメインモデル（エンティティ）や値オブジェクト、集約を定義します。
- ビジネスルールや制約に基づく検証メソッドを持ち、状態遷移の正当性を担保します。
- ドメイン知識そのものを表現し、アプリケーション層やインフラ層に依存しません。
- ドメイン層の安定性を保つため、下位層の実装（インフラ層など）を直接参照しないでください。
- 厳密な Domain Driven Design を意識する必要はありませんので、すべて `Models` としてまとめておきます。
- 依存性逆転の原則に従って、インフラ層がドメイン層の抽象に依存するようにするため、`Interfaces` フォルダを作成し、ドメイン層のインターフェースを配置します。
  - `Domain`
    - `Models` (モデル)
    - `Interfaces` (インターフェース)

### Infrastructure Layer (インフラ層)
- データベースへの永続化やクエリ実行、外部公開 API との通信、メール送信など、外部リソースへのアクセスを担当します。
- ドメイン層またはアプリケーション層で定義されたインターフェースを実装し、具象クラスとして提供します。
- 実装クラスはインターフェースに依存し、上位層からはインターフェース経由で呼び出されます。
- `Repositories` には、データベースの CRUD 操作を実装し、`Services` には外部 API との通信やメール送信などのロジックを実装します。サービスやリポジトリのインターフェースは、`Interfaces` フォルダに配置します。
  - `Infrastructure`
    - `Interfaces` (インターフェース)
    - `Repositories` (リポジトリ)
    - `Services` (サービス)

## 依存関係のルール
- 高水準モジュール（ドメイン層やアプリケーション層）は低水準モジュール（インフラ層）に直接依存してはならず、両者は抽象（インターフェース）に依存します。
- 抽象は具象に依存せず、具象が抽象に依存するように実装してください（Dependency Inversion Principle）。
- ドメイン層からインフラ層の具象クラスをインポートすることは避け、必要であればドメイン層にモデルを操作するインターフェース (例えば DB の CRUD など)を提供し、それをインフラ層で実装します。

## C# / ASP.NET 特有のガイド
- DI コンテナ（例：Microsoft.Extensions.DependencyInjection）を利用してインターフェースと実装を登録し、依存性注入を徹底します。
- 非同期処理では `async`/`await` を使用し、スレッドをブロックしないようにします。
- エラー処理では例外を適切にキャッチし、ドメイン例外とアプリケーション例外を区別します。
- 命名規則は PascalCase をクラス、インターフェース、プロパティ、関数に、camelCase を変数に用います。
- インターフェース名は I から始めます
- コントローラー名は `*Controller` で終わるようにし、アクションメソッドは動詞から始めるようにします（例：`GetUser`, `CreateOrder`）
- アプリケーションの設定 (サービスの登録やミドルウェアの設定など) は `Program.cs` に集中させ、明確に分離します
- ロギングは ASP.NET Core の組み込みロガーを使用し、必要に応じてカスタムロガーを実装します
- 反復処理は、可能な限り LINQ を使用して簡潔に記述します